# 倉庫番ゲームをpyxelで実装する
# 毎回データファイルを読み込むのは面倒なので、順番に読み込むようにする
import copy # undo機能を実装するために、深いコピーが必要
import pyxel


# シーン管理のための基底クラス
class Scene:
    def update(self, app):
        pass

    def draw(self):
        pass


# ゲームのタイトル画面
class TitleScene(Scene):
    def update(self, app):
        if pyxel.btnp(pyxel.KEY_RETURN):
            app.change_scene(Sokoban(app.data_files[app.current_file_index]))

    def draw(self):
        pyxel.cls(0)
        pyxel.text(40, 50, "SOKOBAN", pyxel.frame_count % 16)
        pyxel.text(30, 70, "Press RETURN to start", 7)


class Sokoban(Scene):
    def __init__(self, filename):
        # csvファイルを読み込んでゲームの初期状態を設定する
        # 倉庫の中は情報は、辞書で管理する
        # #：壁、$：荷物、@：プレイヤー、*：ゴール
        self.load_map(filename)
        self.tile_size = 8
        self.screen_height = self.tile_size * len(self.warehouse_map)
        self.screen_width = self.tile_size * max(len(line) for line in self.warehouse_map)
        self.moving_step = self.tile_size   # moving_stepフレームの時間をかけて隣に移動する
        self.moving = 0     # 0の時は移動していない、1以上の時は隣のマスに移動中
        self.dx = 0   # 移動方向のx座標の変化量
        self.dy = 0   # 移動方向のy座標の変化量
        self.history = []  # undoのための履歴
        #pyxel.init(self.screen_width, self.screen_height)

    def load_map(self, filename):
        self.warehouse_map = []
        self.goals = []  # ゴールの位置を保存するリスト
        self.player_x = -1
        self.player_y = -1
        self.carry = False  # プレイヤーが荷物を運んでいるかどうか
        # CSVファイルを読み込んでマップを作成する
        # Encodingはutf-8-sigを指定してBOMを無視する
        with open(filename, 'r', encoding='utf-8-sig') as file:
            for y, y_line in enumerate(file):
                y_line = y_line.strip().split(',')
                line = []
                for x, char in enumerate(y_line):
                    if char == '#':
                        line.append('#')
                    elif char == '$':
                        line.append('$')
                    elif char == '@':
                        line.append('@')
                        self.player_x = x
                        self.player_y = y
                    elif char == '*':
                        self.goals.append((x, y))
                        line.append(' ')    # ゴールは空白として扱う
                    elif char == '+':  # プレイヤーがゴールの上にいる場合（記号を使いたい場合）
                        self.goals.append((x, y))
                        line.append('@')
                        self.player_x = x
                        self.player_y = y
                    elif char == '!':  # 荷物がゴールの上にある（新ルール用記号）
                        self.goals.append((x, y))
                        line.append('$')  # 荷物をマップに置く
                    else:
                        # 壁でも、荷物でも、プレイヤーでもない場合は空白を追加
                        line.append(' ')
                # 読み込んだ行をマップに追加
                self.warehouse_map.append(line)

    def can_move(self, dx, dy):
        new_x = self.player_x + dx
        new_y = self.player_y + dy

        # 移動先が壁なら移動できない
        if self.warehouse_map[new_y][new_x] == '#':
            return False
        # 移動先が荷物なら、荷物を押せるか確認
        if self.warehouse_map[new_y][new_x] == '$':
            # 荷物を押す場合、荷物の先に壁がないか確認
            next_x = new_x + dx
            next_y = new_y + dy
            if (0 <= next_x < len(self.warehouse_map[0]) and
                0 <= next_y < len(self.warehouse_map) and
                self.warehouse_map[next_y][next_x] not in ['#', '$']):
                # 荷物の先が壁でない場合は移動可能
                self.carry = True
                return True
            else:
                return False
        # これら以外は移動可能
        # つまり、空白またはゴールの場合は移動可能
        return True

    def finish(self):
        # 全ての荷物がゴールに到達しているか確認する
        for x, y in self.goals:
            if self.warehouse_map[y][x] != '$':
                return False
        return True

    def update(self, app):
        if self.moving > 0:
            # 移動中なので、時間を進める
            self.moving -= 1
            if self.moving == 0:
                # 移動が完了したら、プレイヤーの位置を更新
                # プレイヤーの位置を更新
                self.warehouse_map[self.player_y][self.player_x] = ' '
                self.player_x += self.dx
                self.player_y += self.dy
                self.warehouse_map[self.player_y][self.player_x] = '@'
                if self.carry:
                    # 荷物を押していた場合は荷物の位置も更新
                    box_x = self.player_x + self.dx
                    box_y = self.player_y + self.dy
                    # 荷物の位置を更新
                    self.warehouse_map[box_y][box_x] = '$'
                self.carry = False  # 移動が完了したら、荷物を運んでいない状態に戻す
            if self.finish():
                app.current_file_index = (app.current_file_index + 1) % len(app.data_files)
                app.change_scene(ClearScene())
            return

        direction = {
            pyxel.KEY_UP: (0, -1),
            pyxel.KEY_DOWN: (0, 1),
            pyxel.KEY_LEFT: (-1, 0),
            pyxel.KEY_RIGHT: (1, 0)
        }
        for key, (dx, dy) in direction.items():
            if pyxel.btnp(key):
                if self.can_move(dx, dy):
                    # 状態保存
                    self.save_state()
                    # 移動可能なら移動を開始
                    self.moving = self.moving_step
                    self.dx = dx
                    self.dy = dy
        if pyxel.btnp(pyxel.KEY_Z):  # ZキーでUndo
            self.undo()
            return

    def draw(self):
        pyxel.cls(0)
        # まずはゴールを描画する
        for x, y in self.goals:
            pyxel.rect(x * self.tile_size, y * self.tile_size, self.tile_size, self.tile_size, 11)
        # 次に単純にマップを描画する
        for y, line in enumerate(self.warehouse_map):
            for x, char in enumerate(line):
                if char == '#':
                    pyxel.rect(x * self.tile_size, y * self.tile_size, self.tile_size, self.tile_size, 1)
                elif char == '$':
                    # 荷物の位置がゴールにある場合は色を変える
                    col = 10 if (x, y) not in self.goals else 4
                    pyxel.rect(x * self.tile_size, y * self.tile_size, self.tile_size, self.tile_size, col)
                elif char == '@':
                    pyxel.rect(x * self.tile_size, y * self.tile_size, self.tile_size, self.tile_size, 9)
        if self.moving == 0:
            # プレイヤーが移動していないなら、やること無し
            return
        # プレイヤーが移動中なら
        px = self.player_x + self.dx * (self.moving_step - self.moving) / self.moving_step
        py = self.player_y + self.dy * (self.moving_step - self.moving) / self.moving_step
        bx = self.player_x + 2*self.dx * (self.moving_step - self.moving) / self.moving_step
        by = self.player_y + 2*self.dy * (self.moving_step - self.moving) / self.moving_step
        pyxel.rect(px * self.tile_size, py * self.tile_size, self.tile_size, self.tile_size, 9)
        if self.carry:
            # 荷物を押している場合は荷物の位置も更新
            pyxel.rect(bx * self.tile_size, by * self.tile_size, self.tile_size, self.tile_size, 10)

    # undo機能を実装に利用する
    # 盤面の情報を全てコピーするので、メモリを使うが、実装は簡
    def save_state(self):
        # 深いコピーをして現在の状態を履歴に保存
        state = {
            "map": copy.deepcopy(self.warehouse_map),
            "player_x": self.player_x,
            "player_y": self.player_y
        }
        self.history.append(state)

    # undo機能を実装するためのメソッド
    def undo(self):
        if not self.history:
            return
        # historyの一番最後の要素を取り出して、現在の状態を復元
        last_state = self.history.pop()
        self.warehouse_map = last_state["map"]
        self.player_x = last_state["player_x"]
        self.player_y = last_state["player_y"]


# ゲームクリア画面
class ClearScene(Scene):
    def update(self, app):
        # スペースキーでタイトルに戻る
        if pyxel.btnp(pyxel.KEY_SPACE):
            app.change_scene(TitleScene())
        # Returnキーで次のレベルへ進む
        if pyxel.btnp(pyxel.KEY_RETURN):
            app.change_scene(Sokoban(app.data_files[app.current_file_index]))
        # ESCキーで終了
        elif pyxel.btnp(pyxel.KEY_ESCAPE):
            pyxel.quit()

    def draw(self):
        pyxel.cls(0)
        pyxel.text(40, 50, "CLEAR!", 10)
        pyxel.text(20, 70, "Press Return to Try next level", 7)
        pyxel.text(20, 90, "Press Space to return to Title", 7)
        pyxel.text(20, 110, "or ESC to exit", 7)


class App:
    def __init__(self):
        pyxel.init(255, 255)
        pyxel.title("Sokoban")
        self.current_scene = TitleScene()
        # データファイルを順番に読み込むための初期化
        # 複数の倉庫データファイルを用意しておけば、この順番でプレーが出来る
        self.data_files = [
            "warehouse01.csv",
            "warehouse02.csv",
            "warehouse03.csv",
            "warehouse04.csv",
            "warehouse05.csv",
            "warehouse06.csv",
            "warehouse07.csv"
        ]
        self.current_file_index = 0

        pyxel.run(self.update, self.draw)

    def change_scene(self, scene):
        self.current_scene = scene

    def update(self):
        self.current_scene.update(self)

    def draw(self):
        self.current_scene.draw()


if __name__ == "__main__":
    App()

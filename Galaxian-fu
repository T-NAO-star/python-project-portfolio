# -*- coding: utf-8 -*-
# ギャラクシアンゲーム風のシューティングゲーム
# 衝突判定を実装
import pyxel

WIDTH, HEIGHT = (80, 40)
WINDOW_SIZE = (WIDTH * 2, HEIGHT * 5)


def constrain(value, min_value, max_value):
    """値を指定された範囲に制限する"""
    return max(min_value, min(value, max_value))


class AABB:
    """Axis-Aligned Bounding Box (AABB) クラス"""
    def __init__(self, x, y, width, height):
        self.x = x  # X座標
        self.y = y  # Y座標
        self.width = width  # 幅
        self.height = height  # 高さ

    def intersects(self, other):
        """他のAABBと衝突しているかどうかを判定"""
        min1 = (self.x, self.y)
        max1 = (self.x + self.width, self.y + self.height)
        min2 = (other.x, other.y)
        max2 = (other.x + other.width, other.y + other.height)
        return (min1[0] < max2[0] and
                max1[0] > min2[0] and
                min1[1] < max2[1] and
                max1[1] > min2[1])
    
    def intersects_vertical_line(self, x, y, height):
        """Y座標のラインと衝突しているかどうかを判定"""
        return (self.x < x + 2 and
                self.x + self.width > x and
                self.y < y + height and
                self.y + self.height > y)


class Star:
    """星のクラス"""
    def __init__(self, x, y, color):
        self.x = x  # 星のX座標
        self.y = y  # 星のY座標
        self.color = color  # 星の色

    def draw(self):
        # 星を描画
        pyxel.pset(self.x * 2, self.y * 5, self.color)

    def is_alive(self):
        """星が画面内にいるかどうかを判定"""
        return 0 <= self.y < HEIGHT

    def update(self):
        """星の更新処理"""
        # 星は画面の下から上に移動する
        self.y += 1
        if not self.is_alive():
            # 画面外に出たら、再度画面下から生成
            self.y = 0
            self.x = pyxel.rndi(0, WIDTH - 1)
            self.color = pyxel.rndi(1, 15)      # ランダムな色を設定、ただし黒は除外


class Background:
    """背景のクラス"""
    def __init__(self):
        self.stars = []  # 星のリスト
        for _ in range(100):  # 100個の星を生成
            x = pyxel.rndi(0, WIDTH - 1)
            y = pyxel.rndi(0, HEIGHT - 1)
            color = pyxel.rndi(1, 15)  # ランダムな色を設定、ただし黒は除外
            self.stars.append(Star(x, y, color))

    def update(self):
        """背景の更新処理"""
        # フレームカウントが32の倍数のときに星を更新
        if pyxel.frame_count % 32 != 0:
            return
        for star in self.stars:
            star.update()

    def draw(self):
        pyxel.cls(0)  # 画面をクリア
        """背景の描画処理"""
        for star in self.stars:
            star.draw()


class Explosion:
    """爆発のクラス"""
    def __init__(self, x, y, life=8):
        self.x = x  # 爆発のX座標
        self.y = y  # 爆発のY座標
        self.life = life  # 残りフレーム数

    def update(self):
        """爆発の更新処理"""
        self.life -= 1
        if self.life <= 0:  # 10フレームで爆発を終了
            return False
        return True

    def draw(self):
        """爆発の描画処理"""
        pyxel.blt(self.x * 2, self.y * 5, 0, (self.life % 2 + 11) * 10, 0, 10, 4)


class ExplosionManager:
    """爆発管理クラス"""
    def __init__(self):
        self.explosions = []  # 爆発のリスト

    def add_explosion(self, x, y, life=8):
        """爆発を追加する"""
        self.explosions.append(Explosion(x, y, life))

    def update(self):
        """爆発の更新処理"""
        for explosion in self.explosions:
            if not explosion.update():
                # 爆発のライフが0になったら削除
                self.explosions.remove(explosion)

    def draw(self):
        """爆発の描画処理"""
        for explosion in self.explosions:
            explosion.draw()


class Beam:
    """ビーム（弾）のクラス"""
    def __init__(self, x=0, y=0):
        self.x = x  # ビームのX座標
        self.y = y  # ビームのY座標
        self.shot = False

    def fire(self, x, y):
        """ビームを発射する"""
        self.x = x
        self.y = y
        self.shot = True

    def update(self):
        """ビームの移動処理"""
        if not self.underShot():
            return
        self.y -= 1
        # ビームが画面外に出たら発射状態を解除
        if self.y <= 0:
            self.shot = False

    def underShot(self):
        """ビームが発射されているかどうかを判定"""
        return self.shot

    def draw(self):
        if self.underShot():
            pyxel.rectb(self.x * 2, self.y * 5, 2, 4, 9)

    def bounding_box(self):
        """ビームのバウンディングボックスを返す"""
        if not self.underShot():
            return None
        # ビームのバウンディングボックスを返す
        return AABB(self.x * 2, self.y * 5, 2, 4)


class Fighter:
    """攻撃機（プレイヤー機）のクラス"""
    def __init__(self, beam=None):
        self.x = int(WIDTH / 2-2)  # 攻撃機のX座標
        self.y = HEIGHT - 3        # 攻撃機のY座標
        self.beam = beam

    def update(self):
        if pyxel.btn(pyxel.KEY_LEFT):
            self.x -= 1
        if pyxel.btn(pyxel.KEY_RIGHT):
            self.x += 1
        self.x = constrain(self.x, 0, WIDTH - 4)  # X座標を制限
        if pyxel.btn(pyxel.KEY_SPACE) and not self.beam.underShot():
            # スペースキーが押されたらビームを発射
            self.beam.fire(self.x + 2, self.y - 1)

    def draw(self):
        pyxel.blt(self.x * 2, self.y * 5, 0, 13 * 10, 0, 10, 4)
        # 攻撃機のビーム（弾）の部分を描画
        if not self.beam.underShot():
            pyxel.rectb((self.x + 2) * 2, (self.y - 1) * 5, 2, 4, 9)

    def bounding_box(self):
        """攻撃機のバウンディングボックスを返す"""
        return AABB(self.x * 2, self.y * 5, 10, 4)


class Missile:
    """ミサイルのクラス"""
    def __init__(self, x, y):
        self.x = x  # ミサイルのX座標
        self.y = y  # ミサイルのY座標

    def draw(self):
        """ミサイルの描画処理"""
        pyxel.rectb(self.x * 2, self.y * 5, 2, 4, 10)

    def update(self):
        """ミサイルの更新処理"""
        if not self.is_alive():
            return
        # 2フレームに1回の割合で更新
        if pyxel.frame_count % 2 != 0:
            return
        self.y += 1  # 上に移動

    def is_alive(self):
        """ミサイルが画面内にいるかどうかを判定"""
        return 0 <= self.x < WIDTH and 0 <= self.y < HEIGHT

    def bounding_box(self):
        """ミサイルのバウンディングボックスを返す"""
        return AABB(self.x * 2, self.y * 5, 2, 4)


class MissileManager:
    """ミサイル管理クラス"""
    def __init__(self):
        self.max_missiles = 10  # 最大ミサイル数
        self.missiles = []  # ミサイルのリスト
        self.lower = 0.7  # ミサイルのY座標の下限（画面の下部の70%）

    def launch_missile(self, x, y):
        """ミサイルを追加する"""
        # ミサイルの数が最大数に達している場合は何もしない
        if len(self.missiles) >= self.max_missiles:
            return
        # ミサイルのY座標が画面の下部に近い場合はミサイルを発射しない
        if y < 4 or y > int(HEIGHT * self.lower):
            return
        if pyxel.rndi(0, 9) == 0:   # 10%の確率でミサイルを発射
            self.missiles.append(Missile(x, y))

    def update(self):
        """ミサイルの更新処理"""
        for missile in self.missiles:
            missile.update()
            if not missile.is_alive():
                self.missiles.remove(missile)  # 画面外に出たミサイルは削除

    def draw(self):
        """ミサイルの描画処理"""
        for missile in self.missiles:
            missile.draw()


# エイリアンのクラス
class Alian:
    def __init__(self, kind, x, y, dx):
        self.x = x  # エイリアンのX座標
        self.y = y  # エイリアンのY座標
        self.dx = dx  # エイリアンのX方向の移動量
        self.kind = kind  # エイリアンの種類（1～7まで）
        self.state = 0  # エイリアンの状態（0:通常, 1:攻撃中, 2:破壊中, 3:回収処理中）
        self.alive = True  # エイリアンの生存状態
        self.original = (kind, x, y, dx)  # エイリアンの最初の状態を保存

    def draw(self):
        """エイリアンの描画処理"""
        if self.state == 0:
            # エイリアンの描画
            pyxel.blt(self.x * 2, self.y * 5, 0, (self.kind - 1) * 10, 0, 10, 4)
        elif self.state == 1:
            pyxel.blt(self.x * 2, self.y * 5, 0,(self.kind - 1) * 10, 0, 10, 4)
        elif self.state == 2:
            pass
        else:
            raise ValueError("Invalid state for Alian: {}".format(self.state))

    def move(self, dx):
        """エイリアンの移動処理"""
        if self.state != 0:
            return
        self.x += dx  # X座標を更新
        # エイリアン毎に2パターンの画像を切り替える
        if self.kind <= 2:
            self.kind = 3 - self.kind
        elif self.kind <= 4:
            self.kind = 7 - self.kind
        elif self.kind <= 6:
            self.kind = 11 - self.kind

    def attack(self, missile_manager):
        """エイリアンの攻撃処理"""
        # 攻撃中の状態でなければ何もしない
        if self.state != 1:
            return
        kind = self.kind
        x = self.x
        y = self.y
        if kind == 8:
            if y == 7:
                self.dx = pyxel.rndi(-2, 2)
        if kind == 9:
            if y == 6:
                self.dx = pyxel.rndi(-5, 5)
        if kind == 10:
            if y == 5:
                self.dx = pyxel.rndi(-2, 2)
        if kind == 11:
            if y == 3:
                self.dx = pyxel.rndi(-2, 2)
        x += self.dx
        y += 1
        # エイリアンの攻撃が画面外に出た場合は攻撃を終了し、初期状態に戻す
        if x < 0 or x > WIDTH - 4 or y > HEIGHT:
            self.alive = True
            self.state = 3  # 回収処理中の状態にする
            self.kind, self.x, self.y, self.dx = self.original  # 初期状態に戻す
        else:
            # 攻撃中のエイリアンの状態を更新
            self.x = x
            self.y = y
            # ミサイルを発射
            missile_manager.launch_missile(x, y)

    def update(self):
        pass

    def bounding_box(self):
        """エイリアンのバウンディングボックスを返す"""
        return AABB(self.x * 2, self.y * 5, 10, 4)


# エイリアンのクラス1
# 各エイリアンの種類、X座標、Y座標、移動方法を定義
# エイリアンの種類は1～7まであり、
class Troops:
    alian_initial_deploy_data = [
        # 各エイリアンのデータ
        # (エイリアンの種類, X座標, Y座標, 移動方法)
        # このリストに記載されている順番でエイリアンが攻撃を行う
        (1, 59, 5,  3),    # 0
        (1, 19, 5, -3),    # 1
        (4, 54, 4,  3),    # 2
        (4, 24, 4, -3),    # 3
        (1, 59, 6,  3),    # 4
        (1, 19, 6, -3),    # 5
        (2, 54, 5,  3),    # 6
        (2, 24, 5, -3),    # 7
        (1, 59, 7,  3),    # 8
        (1, 19, 7, -3),    # 9
        (2, 54, 6,  3),    # 10
        (2, 24, 6, -3),    # 11
        (2, 54, 7,  3),    # 12
        (2, 24, 7, -3),    # 13
        (3, 49, 4,  3),    # 14
        (3, 29, 4, -3),    # 15
        (1, 49, 5,  3),    # 16
        (1, 29, 5, -3),    # 17
        (1, 49, 6,  3),    # 18
        (1, 29, 6, -3),    # 19
        (1, 49, 7,  3),    # 20
        (1, 29, 7, -3),    # 21
        (4, 44, 4,  3),    # 22
        (4, 34, 4, -3),    # 23
        (3, 39, 4,  3),    # 24
        (2, 44, 5,  3),    # 25
        (1, 39, 5, -3),    # 26
        (2, 34, 5, -3),    # 27
        (2, 34, 6, -3),    # 28
        (1, 39, 6,  3),    # 29
        (2, 44, 6,  3),    # 30
        (2, 44, 7,  3),    # 31
        (1, 39, 7, -3),    # 32
        (2, 34, 7, -3),    # 33
        (5, 29, 3, -3),    # 34
        (6, 34, 3, -3),    # 35
        (5, 39, 3, -3),    # 36
        (6, 44, 3,  3),    # 37
        (5, 49, 3,  3),    # 38
        (7, 34, 2, -3),    # 39
        (7, 44, 2,  3),    # 40
    ]

    def __init__(self):
        self.alians = []    # エイリアンのリスト
        for a in Troops.alian_initial_deploy_data:
            self.alians.append(Alian(a[0], a[1], a[2], a[3]))
        self.move_dir = 1  # エイリアンの軍団の移動方向（1:右, -1:左）
        self.offset_x = 0  # エイリアンのX座標のオフセット
        self.missile_manager = MissileManager()  # ミサイル管理クラスのインスタンスを生成

    def choose_attacker(self):
        """攻撃中のエイリアンを選択する"""
        # フレームカウントが32の倍数のときに攻撃エイリアンを選択
        if pyxel.frame_count % 32 != 0:
            return
        # 攻撃するエイリアンを決める
        for a in self.alians:
            if a.state == 0:  # 攻撃中でないかつ生存しているエイリアンを探す
                a.state = 1  # 攻撃中の状態にする
                a.alive = False  # 攻撃済みのエイリアンは生存状態をFalseにする
                a.kind = int((a.kind + 1) / 2) + 7
                break
        else:
            # すべてのエイリアンが攻撃済みの場合は終了
            return

    def move(self):
        """エイリアンの移動処理"""
        # エイリアンの移動はフレームカウントが8の倍数のときに行う
        if pyxel.frame_count % 8 != 0:
            return
        # 時々（32フレームに1回）エイリアンを移動させる
        mf = 1 if pyxel.frame_count % 32 == 0 else 0
        self.offset_x += mf * self.move_dir  # エイリアンのX座標のオフセットを更新
        # エイリアンの移動
        min_x = WIDTH  # エイリアンの最小X座標
        max_x = 0      # エイリアンの最大X座標
        for a in self.alians:
            if a.state != 0:
                continue
            a.move(mf*self.move_dir)  # エイリアンの移動
            min_x = min(min_x, a.x)
            max_x = max(max_x, a.x)
        if min_x < 11:
            self.move_dir = 1
        if max_x > WIDTH - 16:
            self.move_dir = -1

    def update(self):
        self.move()  # エイリアンの移動処理
        self.choose_attacker()  # 攻撃するエイリアンを選択
        self.attack(self.missile_manager)  # エイリアンの攻撃処理
        for a in self.alians:
            if a.state == 3:  # 回収処理中のエイリアン
                a.state = 0
                a.x += self.offset_x  # オフセットを適用
        self.missile_manager.update()

    def attack(self, missile_manager):
        """エイリアンの攻撃処理"""
        # 3フレームに1回、攻撃処理を更新する
        if pyxel.frame_count % 3 != 0:
            return
        for a in self.alians:
            a.attack(missile_manager)  # 各エイリアンの攻撃処理を呼び出す

    def get_missiles(self):
        """エイリアンのミサイルを取得する"""
        return self.missile_manager.missiles
    
    def draw(self):
        """エイリアンの描画処理"""
        for a in self.alians:
            a.draw()
        self.missile_manager.draw()


# ギャラクシアンのメインクラス
class Galaxian:
    def __init__(self):
        # pyxelの初期化
        # ウィンドウサイズを設定
        pyxel.init(*WINDOW_SIZE)    # pyxel.init(WINDOW_SIZE[0], WINDOW_SIZE[1])と同じ
        pyxel.title("Galaxian")

        # 各キャラクタの準備
        pyxel.load("galaxian.pyxres")
        pyxel.playm(0, loop=True)#音の再生

        self.alians = Troops()
        self.background = Background()  # 背景のインスタンスを生成
        self.beam = Beam()  # ビーム（弾）のインスタンスを生成
        self.fighter = Fighter(self.beam)  # 攻撃機のインスタンスを生成
        self.explosion_manager = ExplosionManager()  # 爆発管理クラスのインスタンスを生成

        self.score = 0  # 得点

        self.is_game_over = False  # ゲーム終了フラグ

        # pyxelの実行
        # Galaxianのインスタンスを生成したときに、自動的にゲームがスタート
        pyxel.run(self.update, self.draw)

    def check_collision_with_beam(self):
        """ビームとエイリアンの衝突判定"""
        # ビームが発射されていない場合は何もしない
        if not self.beam.underShot():
            return
        # ビームのバウンディングボックスを取得
        beam_box = self.beam.bounding_box()
        # エイリアンとビームの衝突判定
        for alian in self.alians.alians:
            if alian.state == 2 or alian.state == 3:
                # 破壊状態のエイリアンは無視
                continue
            abox = alian.bounding_box()
            # AABBの衝突判定
            if beam_box.intersects(abox):
                # 衝突したエイリアンを破壊状態にする
                alian.state = 2
                # エイリアンの位置に爆発を追加
                self.explosion_manager.add_explosion(alian.x, alian.y)
                self.score += 100  # 得点アップ
                # 一匹のエイリアンを破壊したら、ビームを消す
                self.beam.shot = False
                # もう敵を倒したので、判定処理は終わり
                break

    def check_collision_with_missile(self):
        """ミサイルと攻撃機の衝突判定"""
        # 攻撃機のバウンディングボックスを取得
        fighter_box = self.fighter.bounding_box()
        for missile in self.alians.get_missiles():
            if not missile.is_alive():
                continue
            # 衝突判定
            if fighter_box.intersects(missile.bounding_box()):
                # 攻撃機がミサイルに当たった場合の処理
                # 攻撃機の位置に爆発を追加
                self.explosion_manager.add_explosion(self.fighter.x, self.fighter.y, 10)
                # とりあえずゲームオーバーを表示してから、いきなり修了
                self.destroy_fighter()

    def check_collision_with_alians(self):
        """攻撃機とエイリアンの衝突判定"""
        # 攻撃機のバウンディングボックスを取得
        fighter_box = self.fighter.bounding_box()
        for alian in self.alians.alians:
            # 攻撃中のエイリアンだけを対象とする。
            if alian.state != 1:
                continue
            # 衝突判定
            if fighter_box.intersects(alian.bounding_box()):
                # 攻撃機がエイリアンに当たった場合の処理
                # 攻撃機の位置に爆発を追加
                self.explosion_manager.add_explosion(self.fighter.x, self.fighter.y, 10)
                # とりあえずゲームオーバーを表示してから、いきなり修了
                self.destroy_fighter()

    # プレイヤーの攻撃機が破壊されたの処理
    def destroy_fighter(self):
        """攻撃機が破壊された場合の処理"""
        # とりあえずゲームオーバーを表示してから、いきなり修了
        # 何か工夫をしないとダメ。
        print("Game Over! Your fighter was destroyed!")
        # ゲームを終了
        pyxel.quit()

    def update(self):
        """フレーム更新時の処理"""

        if self.is_game_over:
            return  # ゲーム終了時は更新処理を止める

        # エイリアンの移動 
        # キー入力チェック
        # 各キャラクタの移動
        self.background.update()
        # 攻撃機、エイリアン、ビームの更新処理
        self.alians.update()
        self.fighter.update()
        self.beam.update()
        # 衝突判定
        # ビームとエイリアンの衝突判定
        if self.beam.underShot():
            self.check_collision_with_beam()
        # ミサイルと攻撃機の衝突判定
        self.check_collision_with_missile()
        # 攻撃機とエイリアンの衝突判定
        self.check_collision_with_alians()
        # 爆発の更新処理
        self.explosion_manager.update()

        # エイリアンが全滅したか
        if all(a.state == 2 for a in self.alians.alians):
            self.is_game_over = True



    def draw(self):
        """描画処理"""
        # 画面の初期化
        self.background.draw()
        # 各キャラクタの描画処理
        self.alians.draw()
        self.fighter.draw()
        self.beam.draw()
        # 爆発の描画処理
        self.explosion_manager.draw()
        pyxel.text(5, 5, f"SCORE: {self.score}", 7)

        if self.is_game_over:
            pyxel.text(60, 60, "GAME CLEAR!", 8)  # 中央に表示



# メイン関数
# Galaxianクラスのインスタンスを生成して、ゲームを開始
if __name__ == "__main__":
    Galaxian()
